#+title: Notes on Emacs
#+author: Various
#+filetags: NOTE

#+options: toc:t

This is a small collection of Emacs related posts and documentation by other
authors that I find useful.

* Emacs Features

** Eshell

- [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][Mastering Eshell]] by Mickey Petersen
- [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][Eschewing Zshell for Emacs Shell]] by Howard Abrams
- [[https://github.com/howardabrams/dot-files/blob/master/emacs-eshell.org][Abrams' EShell configuration]]

* Workshop for Emacs Macros

(By [[https://www.howardism.org/][Howard Abrams]], 2015 Nov 24)

Basic idea of this file is to be both a *guide* and a *practice pad*
for leveling up on Emacs’ keyboard macro system.

To use, just [[https://github.com/howardabrams/pdx-emacs-hackers/raw/master/workshops/keyboard-macros.org][download this file]] to your system, and edit it in Emacs.
Then just follow along... If you are not familiar with org-mode files,
here are the basics for this workshop:

  - Hit a tab on the header expands or collapses it
  - Narrow to show just one section with: C-x n s
  - Return by widening normally with: C-x n w
  - Hyperlinks can be clicked on to view the Emacs Manual

Pretty much treat the rest of this document as a text file.

** Basic Usage

  Let’s begin with something simple to try out this project.
  In the /block area/ below, hit: C-c ' (yes, the apostrophe).
  When done with the tasks, hit: C-x C-s to close and return here.

  #+BEGIN_SRC org
    - This foobar should be Interesting
    - Nulla foobar Posuere
    - Nullam foobar Tempus
    - Etiam foobar laoreet quam sed Arcu
    - Donec foobar hendrerit tempor Tellus
    - Mauris foobar mollis tincidunt Felis
    - etiam laoreet quam sed arcu
    - nullam rutrum
    - sed diam
    - lorem ipsum dolor sit amet, consectetuer adipiscing elit
    - mauris ac felis vel velit tristique imperdiet
    - fusce suscipit, wisi nec facilisis facilisis, est dui fermentum leo, quis tempor ligula erat quis odio
    - donec hendrerit tempor tellus
  #+END_SRC

  Notice that the frame is split with this document still visible?

  Good, let’s play around. Let’s capitalize the first letter of each line.
  Position point at the beginning of the first line, and then:

  - F3
  - M-c
  - C-n
  - C-a
  - F4

  Press F4 repeatedly to capitalize the first word on each line.
  Don’t capitalize /every/ line... leave a few alone for a moment.
  Now you have the basics.

  Let’s make a new macro to capitalize the /last/ word on each line.
  Pop back up to the top of the list, and:

  - F3
  - C-e
  - M-b
  - M-c
  - C-n
  - F4

  Once again, leave a few lines alone.
  Just one more macro, as I want to show you something interesting.
  Jump back to the beginning, and:

  - F3
  - C-a
  - M-f
  - Space
  - foobar (or type any single word you find amusing)
  - C-n
  - F4

  Type: C-x C-k C-k

  Notice it behaves the same as F4, but you can keep typing C-k to
  execute your macro.

  Start typing C-n and/or C-p and notice the minibuffer. It alternates
  between the following:

  - M-c C-n C-a
  - C-e M-b M-c C-n
  - C-a M-f SPC f 2*o b a r C-n

  Typing C-k at any point will execute that macro. You’ve now see the
  Emacs Macro Ring, and can manipulate it. You are now at Level 2.

  Type C-c ' (apostrophe) to close that side window.

** Naming Macros

  While that =foobar= macro may be quite handy, looping around the
  keyboard macro ring to select it may be inefficient. Name it!

     C-x C-k n

  Give it a name of foobar, and now, you can: M-x foobar
  to have the macro run.

  Perhaps it may be more useful to bind that macro to some un-used
  key, like C-c k or F2 ... type:

     C-x C-k b

  And then type your binding, e.g. C-c k

  You know that C-c followed by a single letter is supposed to be free
  of usage and available for your nefarious reasons, right?

  Read the [[info:emacs#Save%20Keyboard%20Macro][the Emacs Manual]] for details. If you actually tried this
  example, then you have earned enough experience points to be level 3.

** What do you mean On Every Line?

  Keyboard macros are slick, and while we /could/ prefix the F4 with
  the numbering prefix to run it multiple times at once, e.g. C-9 F4,
  a typical use case is to run it on every line in a region.

  Position the cursor in the block, and type: C-c ‘

  #+BEGIN_SRC org
    I will not take out the trash
    I should not stop swearing
    I may not stop to smell the roses
    I do not want to go shopping
    I could not care less
  #+END_SRC

  With the point on the first line, type:

  - F3
  - C-a
  - M-f
  - M-f
  - Space
  - not (type the word, =not=)
  - F4

  Now select the remaining 4 lines any way you like, and type:

  - C-x C-k r

  Read [[info:emacs#Basic%20Keyboard%20Macro][the Emacs Manual]] for complete details, and welcome to level 4.

** Numbering

  Numbering things seems to be important to people. Let’s see if we
  can easily number the worst song ever inflicted on humanity.

  Once again, position the point inside the block, and type: C-c '

  #+BEGIN_SRC org
    1 Drummers Drumming
    2 Pipers Piping
    3 Lords a Leaping
    4 Ladies Dancing
    5 Maids a Milking
    6 Swans a Swimming
    7 Geese a Laying
    8 Golden Rings
    9 Calling Birds
    10 French Hens
    11 Turtle Doves
    12 Partridge in a Pear Tree
  #+END_SRC

  Follow along at home. First, position the point at the end (on the
  line with the partridge), and:

  - C-x C-k C-c
  - 1
  - Return (to set a counter to 1)
  - F3
  - C-a
  - F3
  - Spacebar
  - C-n
  - F4

  Yes, hitting the F3 key twice (once to start the macro, and again to
  insert the value of the counter) is a bit odd. You can also use the
  binding: C-x C-k C-i

  Each time you hit F4, you increment the counter that is inserted.

  By the way, if you didn’t do the whole =C-x C-k C-c= to set the
  counter to 1, the first value would be 0.  Read [[info:emacs#Keyboard%20Macro%20Counter][the manual]] for
  details.

** Fixing Macros

  Now that you are a Level 5 Elf Keyboard Macro-er, and you can now
  sling macros everywhere, you may notice that sometimes, in the
  middle of a long macro, you flub it.

  If you hit F4 too soon (it happens), hit: C-u C-u F3 to pick up
  where you left off and enter the rest of the macro. Hit F4 when you
  are really finished.

  If you need to fix a keyboard macro with more finesse, type:

      C-x C-k C-e

  And behold the glory. Tis a simple language that should be pretty
  obvious to a skilled Macro-er as yourself. Type C-h m once in that
  buffer to display details of how to edit the macro.  When you are
  finished editing, type: C-c C-c

  I’ll let you play around with your own example for this one.
  Read [[info:emacs#Edit%20Keyboard%20Macro][the manual]] for complete details.

** Variations on a Theme

  To gain the Level 7 Keyboard Macro-er title, one should know how to
  customize a macro /while/ running it. The following section of HTML
  code needs some textual changes. We want to add one of the following
  phrases to the /end/ of every paragraph that has a =class= of =change=:

  * Because I said so. Got it?
  * Because I'm the boss. Got it?
  * You heard me. Got it?
  * Just do it. Got it?

  To begin, first move to the following block (hint: C-c M-f) and hit
  TAB to collapse the block (you gotta see all the instructions,
  right?)  Next, issue a C-c ' on this block to show it in a new
  window. If you have trouble with your HTML mode, change the =html=
  to =text=.

  #+BEGIN_SRC html
    <!DOCTYPE html>
    <html>
      <body>
        <p>
          Proin neque massa, cursus ut, gravida ut, lobortis eget, lacus.
          Praesent augue.  Sed diam.  Nunc eleifend leo vitae magna.  Nunc
          rutrum turpis sed pede.
        </p>
        <p class="change">
          Nullam rutrum.  Nunc rutrum turpis sed pede.
        </p>
        <p>
          Phasellus at dui in ligula mollis ultricies.  Curabitur lacinia
          pulvinar nibh.  Donec pretium posuere tellus.  Praesent
          fermentum tempor tellus.  Proin quam nisl, tincidunt et, mattis
          eget, convallis nec, purus.
        </p>
        <p class="change">
          Fusce sagittis, libero non molestie mollis, magna orci ultrices
          dolor, at vulputate neque nulla lacinia eros.  Sed diam.  Nam
          vestibulum accumsan nisl.
        </p>
        <p>
          Aliquam feugiat tellus ut neque. Nam vestibulum accumsan
          nisl. Praesent fermentum tempor tellus.
        </p>
        <p>
          Vivamus id enim.  Suspendisse potenti.  Curabitur lacinia
          pulvinar nibh.  Mauris ac felis vel velit tristique imperdiet.
        </p>
        <p class="change">
          Donec vitae dolor.  Mauris ac felis vel velit tristique
          imperdiet.  Nunc aliquet, augue nec adipiscing interdum, lacus
          tellus malesuada massa, quis varius mi purus non odio.  Proin
          quam nisl, tincidunt et, mattis eget, convallis nec, purus.  Nam
          euismod tellus id erat.
        </p>
        <p>
          Nullam rutrum.
        </p>
      </body>
    </html>
  #+END_SRC

  Type the following:

  - F3
  - C-s
  - Type: class="change"
  - C-e
  - C-s
  - Type: </p>
  - C-p
  - C-e
  - C-x q
  - Type: Got it?
  - C-n
  - F4

  In this particular case, we actually didn't do anything special, so
  move to the beginning of the buffer, and hit F4, and the cursor will
  go to the end of every paragraph that needs changing, and stop with
  a prompt:

  Proceed with macro? (Y, N, RET, C-l, C-r)

  Type C-r and begin typing one of our phrases, and when you are done,
  type: C-M-c

  The prompt will be re-displayed, so finish the macro with 'Y'.
  Check out [[info:emacs#Keyboard%20Macro%20Query][the manual]] for details on this =C-x q= business.

* Emacs Calc Tutorials

By Andrew Hyatt, found here: https://github.com/ahyatt/emacs-calc-tutorials.
License is GPLv3.

Order as given by https://blog.markhepburn.com/2013/12/07/andrew-hyatts-emacs-calc-tutorials

** README

#+BEGIN_EXAMPLE
This repository contains tutorials about emacs calc originally writen on the
Emacs community on Google+.

The best way to read is probably just to open the org files directly, which
Github will display correctly.

If anyone would like to correct anything, add any tutorials, or request
anything, the normal Github bug / request / or pull request process will work.

#+END_EXAMPLE

** HEX

OK, seems like there's interest in some quick calc tips. Here's today's:

How to convert decimal to hexidecimal. Let's say you want to convert number
12345 to hex.

#+BEGIN_EXAMPLE
M-x calc
d 6 (sets the number radix to 16, meaning all output will be in hex)
10#12345 (inputs the number 12345 in base 10)

The output reads:
1:  16#3039
#+END_EXAMPLE

The answer is therefore =0x3039=.

And then you can do a =d 0= to set the number radix back to normal, base 10.

Here's how to do the other way.  Let's convert =0xABCDEF= to base 10.

#+BEGIN_EXAMPLE
M-x calc
16#ABCDEF

The output reads:
1:  11259375
#+END_EXAMPLE

** Date

Ever want to know how many seconds old David Hasselhoff is? calc can do many
things, but it doesn't know much about Hasselhoff, so first I do a query on
Google for [david hasselhoff]. I get a knowledge card on the right saying he was
born July 17, 1952. It doesn't give a time, so we'll just assume it was at
midnight.

#+BEGIN_EXAMPLE
M-x calc
t N (put the current time on the stack)
'<Jul 17, 1952> (press ' to enter algebraic mode, then you input the date).
- (subtract the two to get the number of days David has been alive)
24 (we're going to multiply by 24, the number of hours in a day)
60 (the number of minutes in an hour)
60 (the number of seconds in a minute)
*
*
*

Final result:
1:  1910255938.01
#+END_EXAMPLE

There you have it, he's... wait, how many seconds?  That's really hard to read.

Back into calc!

#+BEGIN_EXAMPLE
d g (toggle digit grouping)

The final final result:
1:  1,910,255,938.01
#+END_EXAMPLE

Ah, that's a 1.9 billion seconds.  Sweet!

** Time

Hey, what's the time? It's time to get ill! No, actually I meant the time in
seconds since the epoch. Yesterday I went over doing math with time, which is
fun but not something I use everyday. Much more useful is converting to and from
Unix timestamps.

Let's start by getting the time now in seconds since the epoch:

#+BEGIN_EXAMPLE
M-x calc
t N (get the time now)
t U (convert the time to seconds since the epoch)

Result:
1:  1359424746
#+END_EXAMPLE

Oh, and you want to insert that into your last used buffer?

#+BEGIN_EXAMPLE
y (that doesn't mean "yes", that means yank into the last buffer)
#+END_EXAMPLE

Done!  Just to be complete, let's convert another date we have to input:

#+BEGIN_EXAMPLE
'<12:00pm Jul 4, 1776> (single quote to enter algebraic mode, then the date)
t U (converts the time to seconds since the epoch)
#+END_EXAMPLE

But wait, what will happen?  This is considerably before the epoch.

#+BEGIN_EXAMPLE
Result:
1:  -6106003200
#+END_EXAMPLE

Oh calc, you never let me down.

Let's do the other way.  Remember the Billenium?

#+BEGIN_EXAMPLE
1e9
t U (converts the time in seconds since the epoch to text)

Result:
1:  <9:46:40pm Sat Sep 8, 2001>
#+END_EXAMPLE

Wow, I never realized how close the Billenium was to September 11th.  Kind of spooky...

** Random

I use calc whenever I need a random number. The interface is easy and the random
numbers are (supposedly) high quality.

So, let's start with something simple: A random number between 0 and 100:

#+BEGIN_EXAMPLE
M-x calc
100 (the upper bound, all values will be between 0 and this)
k r (creates a random number between 0 and the number on the stack)

Result:
1:  66  (of course, yours will be different)
#+END_EXAMPLE

I want another one!
#+BEGIN_EXAMPLE
k a (creates another number with the same upper bound as the last)
#+END_EXAMPLE

Now that I’ve had a taste of that sweet sweet randomness, I want a vector of 50!

#+BEGIN_EXAMPLE
100 (the upper bound, again)
50 (the number to generate)
k h (generate a vector of 50 random numbers between 0 and 100)

1:  [60, 72, 61, 74, 77, 97, 10, 90, 8, 29, 82, 81, 51, 58, 7, 88, 99, 1, 37, 89, 93, 84, 52, 94, 2, 35, 5, 48, 87, 47, 14, 6, 79, 18, 67, 76, 70, 9, 43, 65, 69, 23, 55, 11, 53, 78, 50, 30, 13, 42]
#+END_EXAMPLE

OK, that's nice.  But how about a number between 0 and 1?

#+BEGIN_EXAMPLE
1.0
k r 

Result:
1:  0.636988102539
#+END_EXAMPLE

OK, how about number between -50 and 50? For that we need to use what calc calls
an interval form:

#+BEGIN_EXAMPLE
[ (Starts interval form)
50 (You can't just type -50 in calc)
n (negate, givint -50)
.. (the middle part of the interval form)
50] (closing the interval form)
#+END_EXAMPLE

What you see now in calc is:
#+BEGIN_EXAMPLE
[-50 .. 50]
#+END_EXAMPLE
And you could have just typed it in with:
#+BEGIN_EXAMPLE
'[-50 .. 50]
#+END_EXAMPLE
which would be a lot easier, really.

#+BEGIN_EXAMPLE
k r
#+END_EXAMPLE
This produces a random number from the bounds of the interval, in this case both
-50 and 50 are possible, if you wanted them to be exlusive bounds, you'd use the
form =(-50 .. 50)=.

Finally, you can re-arrange a list: 
#+BEGIN_EXAMPLE
'[1 2 3 4] (our starting vector) 
-1 (signals to use the vector above, could also be the size of the vector) 
k h

Result:
1:  [3, 1, 4, 2]
#+END_EXAMPLE

But =k a= will not give you more variants, unfortunately.

** Unit Conversion

You load 16 tons, and what do you get?  I mean, in kilograms.

#+BEGIN_EXAMPLE
M-x calc
' 16 tons (' to enter algebraic mode, so you can type out the units)
u c kg (u c for "unit convert", and kg being the target unit).

Result:
1:  14514.95584 kg
#+END_EXAMPLE

Calc treats units as special.  If you added something, such as:

#+BEGIN_EXAMPLE
3
+

Result:
1:  14514.95584 kg + 3
#+END_EXAMPLE

But you can remove the units from the above using:
#+BEGIN_EXAMPLE
u r (remove units)

Result:
1:  14517.95584
#+END_EXAMPLE

OK, that's all well and good. But I've always wondered how much is Grandpa
Simpson's gas mileage when he said "My car gets 40 rods to the hogshead and
that's the way I likes it."

For that, we need to define the units. Calc knows about a lot of units, but
maybe not the rod and hogshead. In fact, in the calc info pages, defining what a
"rod" is the example for how to define your own units. Let's get started!

#+BEGIN_EXAMPLE
'16 ft (The equivalent to one rod)
u d rod Rod (defines a new unit rod, with optional description "Rod")
#+END_EXAMPLE
Now a hogshead is a unit of measurement that varies by what liquid it contains.
I don't know what the unit is for gasoline, but let's use sherry as a
substitute, in which a hogshead is 245 liters.

#+BEGIN_EXAMPLE
'245 liters
u d hogshead (don't bother with a description this time)
'40 rod
'1 hogshead
/
#+END_EXAMPLE
Wait, what units should we be using?
#+BEGIN_EXAMPLE
u v (show the units table, a handy table of all units)
u c mi/gal (the units come from the unit table)

Result:
1:  1.87280731429e-3 mi / gal
#+END_EXAMPLE

But wait, we can do better. Why upgrade this measure to something that isn't
even standard? Miles per gallon is just a bit better than rods per hogshead (in
fact, that was what the original joke was about).

#+BEGIN_EXAMPLE
u c si (convert everything to scientific units)

Result:
1:  796.212244896 / m^2
#+END_EXAMPLE

Not that I understand this number, but at least in miles per gallon, I can see
that that's not such great fuel economy, but what you do expect from Grandpa?

OK, one more cool thing, then I'm out of here. Calc can split up numbers into
multiple units. Here's 42 inches in feet and inches:

#+BEGIN_EXAMPLE
'42 in
u c ft+in (Convert to a mixture of feet and inches)

Result:
1:  3 ft + 6. in
#+END_EXAMPLE

Calc, you're sooo coool!

** Pi and Precision

This one's about  p  and  P  and mostly about pi.

First, let's pi it up:

#+BEGIN_EXAMPLE
M-x calc
P (this gives you pi)

Result:
1:  3.14159265359
#+END_EXAMPLE

Well, I guess that's a reasonable pi. But, c'mon, this is calc. Can't we get a
bit more digits? How about 100?

#+BEGIN_EXAMPLE
p 100 (sets precisions to 100)
P (need to ask calc again for pi, it doesn't recalculate)

Result:
1:  3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068
#+END_EXAMPLE

Well, but actually evaluating it robs it of its never-ending charm. Let's just
use it as a variable. How about calculating the area of a circle with a 5 km
radius?

#+BEGIN_EXAMPLE
'5000 m
2
^
'pi (enter pi as a variable)
*

We get:
1:  25000000 m^2 pi
#+END_EXAMPLE

Yeah, sure that’s what I said I wanted, but I’ve changed my mind - now I want a number.

#+BEGIN_EXAMPLE
=

1:  78539816.3397448309615660845819875721049292349843776455243736148076954101571552249657008706335529267 m^2
#+END_EXAMPLE

Whoops, looked like I forgot to set the precision back to normal. And I can't
read this. Let's make it a bit nicer.

#+BEGIN_EXAMPLE
Control-_ (normal emacs undo)
p 7
d g (turn digit grouping on)
=

Result:
1:  7.853983e7 m^2
#+END_EXAMPLE

Oh, that's because I didn't have enough precision to render it without resorting
to scientific notation. Let's just bump the precision up again.

#+BEGIN_EXAMPLE
Control-_ (undo, since we have to redo the pi conversion with more precision)
p 10
=

Result:
1:  78,539,816.35 m^2
#+END_EXAMPLE

Ah, that's better.

** Strings

Did you know you could work with strings in calc? For an example, let's find out
what "Hello world" is in binary:

#+BEGIN_EXAMPLE
M-x calc
d 2 (change the to binary mode)
"Hello world (Enter the string "Hello world" which turns into a vector of numbers)

Result:
1:  [2#1001000, 2#1100101, 2#1101100, 2#1101100, 2#1101111, 2#100000, 2#1110111, 2#1101111, 2#1110010, 2#1101100, 2#1100100]
#+END_EXAMPLE

And similarly, we can convert back. If someone gave you the binary number:
=01001000011011110110110001100001= and asked what the string was, I'd have no
idea... but calc knows:

#+BEGIN_EXAMPLE
d " (changes to string mode)
C-x b scratch   (whaaa, leave calc?)
01001000011011110110110001100001  (enter the number we're parsing)
C-a  (go to the start of the line)
C-x (  (start a macro)
2# (prefix the number with a binary indicator)
C-u 8 C-f  (Jump forward 8 characters)
<space>  (insert a space to separate the numbers)
C-x )  (end the macro)
C-x e  (repeat the macro)
e e  (repeat twice twice more)
C-<space>  (set mark)
C-a  (goto beginning of line)
C-x <asterisk> g  (copy region into calc)

Result:

1:  "Hola"
#+END_EXAMPLE

And there you have it! Maybe there is an easier way to convert from the giant
binary number to a vector of bytes, but I don't know it yet. 

** Fractional Arithmetic

This one is pretty short, but it's about one of my favorite features of calc:
the ability to handle fractions as fractions instead of rendering them as real
numbers.

Quick, what's =5/8 + 9/21=?

Um, ok... better start multiplying things... wait, let's just tell calc to do
it.

#+BEGIN_EXAMPLE
M-x calc
5:8  (this is how you enter a fraction)
9:21 
+

Result:
1:  59/56
#+END_EXAMPLE

So easy! If we want to convert it to a float you can do this: 

#+BEGIN_EXAMPLE
c f (convert to
float)

Result:

1:  1.05357142857*10.^0
#+END_EXAMPLE

And if you want it back as a fraction, then just do:

#+BEGIN_EXAMPLE
c F  (convert to fraction)

Result:

1:  59/56 
#+END_EXAMPLE

That's so awesome!

You could also enter fractions this way:

#+BEGIN_EXAMPLE
m f  (set fraction mode, integer division will result in fractions)
5
8
/

Result:

1:  5/8
#+END_EXAMPLE

Now you can live in the nice world of fractions as much as you like. It's a nice
world, full of pleasant to look at integers taking up little horizontal space

** Algebra

I think it's time to write about one of the amazing things that calc can do:
algebra!

Before we get into how to solve equations, I just want to write about on some
cool things you can do with the calc display.

Let's say you have a formula you want to work with =a + sqrt(b) =  5=. Let's enter
that into calc:

#+BEGIN_EXAMPLE
M-x calc
'a + sqrt(b) = 5  (' starts algebraic mode).

Result:
1:  a + sqrt(b) = 5
#+END_EXAMPLE

Well, that's not so surprising, that's what we put in. Kind of disappointing,
though. Is that it calc? We love your brains, but what about your looks? That's
important too!

#+BEGIN_EXAMPLE
d B  (turn on calc-big-language mode)

Result:
         ___
1:  a + V b  = 5
#+END_EXAMPLE

Hey, that's an ASCII square-root symbol. What other cool things can you do here?

#+BEGIN_EXAMPLE
a^2

Result:

     2
1:  a

3:4   (enter the fraction 3/4)

Result:

    3
1:  -
    4
#+END_EXAMPLE

Here's how to get back:
#+BEGIN_EXAMPLE
d N  (calc-normal-language)
#+END_EXAMPLE

And an alternative, in which all operators are explicitly represented as
functions:

#+BEGIN_EXAMPLE
1:  a + sqrt(b) = 5  (re-enter the formula)
d U  (calc-unformatted-language)

Result:
1:  eq(add(a, sqrt(b)), 5)
#+END_EXAMPLE

But, wait, did you think that's all? What if you wanted to enter that equation
in Mathematica?

#+BEGIN_EXAMPLE
d M  (calc-mathematica-language)

Result:

1:  a + Sqrt[b] == 5
#+END_EXAMPLE

Ooh!  Calc!  Do c++ next!

#+BEGIN_EXAMPLE
d C  (calc-c-language)

1:  a + sqrt(b) == 5
#+END_EXAMPLE

Latex!

#+BEGIN_EXAMPLE
d L  (calc-latex-language)

Result:

1:  a + \sqrt{b} = 5
#+END_EXAMPLE

I could keep going, but trust me, there's more. And you can even define your own
languages by constructing syntax tables, but I won't get into that now.

** More on Algebra

Jim is 42 years old. He has one brother, and their total age is 100. What is the
brother's age? OK, this isn't a very hard problem, but let's just introduce calc
algebra by solving it.

#+BEGIN_EXAMPLE
M-x calc
'42 + x = 100  (' to enter algebraic input)
a S x  (solve for x)

Result:
1:  x = 58
#+END_EXAMPLE

Let's make this harder. Jim and Dan's ages sum to 100. Jim is 5 years older than
Dan. How old are they?

#+BEGIN_EXAMPLE
'[j + d = 100, d + 5 = j]
a S j,d

Result:
1:  [j = 52.5, d = 47.5]
#+END_EXAMPLE

Nice!

And of course it can give you more than just numerical solutions:

#+BEGIN_EXAMPLE
'sin(x) + tan(y) = pi / 2
a S y  (solve for y)

Result:
1:  y = arctan(pi / 2 - sin(x))
#+END_EXAMPLE

Sometimes there are more than one solution.  For example:
#+BEGIN_EXAMPLE
'x^2 = 25
a S x

Result:
1:  x = 5
#+END_EXAMPLE

Wait, what happened to -5! That's a valid solution, why didn't calc tell us
about it? What's happening here is that calc is telling us about the first valid
thing it can find, which is basically how it operates. But you can always get
everything:

#+BEGIN_EXAMPLE
'x^2 = 25
a P x  (find the polynomial solutions)

Result:
1:  [5, -5]
#+END_EXAMPLE

Sometimes there aren't a finite number of results because you aren't dealing
with polynomials. You can just get a generalized solution:

#+BEGIN_EXAMPLE
'sin(x)^2 = 25
H a S x  (solve for x, giving the generalized solution)

Result:
1:  x = arcsin(5 s1) (-1)^n1 + 180 n1
#+END_EXAMPLE

This uses the calc notation =n1=, which you just means any integer. You can also
see another notation =s1= which means any sign. In this case =5 s1= means that that
number can be 5 or -5.

Looking at how awesome calc is, it's just a shame I never knew about it in high
school...

** Financial

I recently chatted with emacspeak creator T.V. Raman, and told him I was
writing a series of short tutorials about calc. He is really a calc fanatic, and
told me a story in which he astounded a loan officer by calculating scheduled
loan payments with just a few keystrokes in calc. Raman is living proof that
calc is a useful tool for so many situations, and it always pays to have emacs
running. He also mentioned that he found the explanation in the calc tutorial
about the financial functions to be the clearest he's ever read.

So, yes, calc can do finance. Let's say that you were sitting in front of a loan
officer, and she told you that for your loan of $500,000, you need to pay in 30
installments with a 5% interest rate. How much do you need to pay each month?
Wait a second! Stop right there, loan officer! I have calc!

#+BEGIN_EXAMPLE
M-x calc
500000  (the amount of the loan)
30   (the number of payments)
'5%  (equivalent to typing 0.05)
b M  (calc-fin-pmt, computing the amount of periodic payments to amortize a loan)

Result:
1:  25,000
#+END_EXAMPLE

OK, but that's a bit obvious, since $25,000 is just 5% of $500,000. If the
number of payments was much smaller, we'd get a larger value. Let's take another
question: if you wanted to only pay $10,000 in each installment? How many
installments would it take to pay off the loan?

#+BEGIN_EXAMPLE
'5%
10000  (the payment we want to make)
500000  (the loan amount)
b #  (calc-fin-nper, calculate the number of installments needed)

Result
1:  nper(0.05, 10,000, 500,000)
#+END_EXAMPLE

What? Oh, I see, I also go the message: "Payment too small to cover interest
rate: 10000". Oh, right, 5% of $500,000 is already $25,000, so we'd never pay it
off at that rate. What if we payed $50,000 instead?

#+BEGIN_EXAMPLE
'5%
50000  (the payment we want to make)
500000  (the loan amount)
b #

Result:
1: 14.2066908
#+END_EXAMPLE

So, it would take just over 14 payments to pay off the loan.

OK, one more cool one: Let's say you meet an investment banker who gives you the
following deal. I've got a investment for you, she says. Just give me $100,000
and I'll give you $10,000 at the end of each year for the next 12 years.
Assuming the interest rate will stay at 3% for the next 12 years. Is it a good
deal?

Hey, what are you asking me for? I have no idea! Calc knows, though, because it
can tell you the break-even point for the cost of an investment that gives
periodic payments.

#+BEGIN_EXAMPLE
'3%  (the interest rate)
12  (the number of payments)
10000  (the payment you get each time)
b P  (calc-fin-pv, calculate the "present value" of the investment, the break-even point for the investment)

Result:
1:  99,540.0399357
#+END_EXAMPLE

In other words, the break-even point for the initial cost is $99,540. If the
investment costs more than this, it's no good at that assumed interest rate.
Better reject the deal. Trust calc more than any investment banker.

This is just a small sampling of some of the financial calculations that calc
can perform. The next time you are making an investment, fire up calc. You'll
not only have confidence in the deal, you may just amaze someone with the power
of emacs, just like T.V. Raman did.

** Calculus

Quick, integrate =2x + sin(y)=! Well, frankly, it's been so long since I've done
calculus by hand I can't remember anymore. Well, knowing calculus is good, but
knowing calc is even more useful!

#+BEGIN_EXAMPLE
M-x calc
'2x + sin(y)  (The single quote enters algebraic mode)
a i y  (Calculate the integral with respect to y)

Result
1:  2 x y - 180 cos(y) / pi
#+END_EXAMPLE

You can also integrate over specific regions by using C-u a i, whereupon it will
prompt you for the start and end point of the integration.

As the manual mentions, the results are often not as simplified as they could
be. Calc is impressive, but it isn't as sophisticated as Mathematica.

An example of some issues are if we just take the derivative of the integral we
just calculated. We should get back to our original formula.

#+BEGIN_EXAMPLE
a d y  (Calculate the derivative with respect to y)

Result:
1:  2 x + 3.14159265358 sin(y) / pi
#+END_EXAMPLE

Clearly this should be 2x + sin(y), but calc may have made an error.

OK, let's make calc do something cool so we can forget this unfortunate
incident. Hey, how about making a Taylor series of a function?

#+BEGIN_EXAMPLE
'2x + sin(y) (re-enter the formula)
a t y 6  (Calculate the Taylor series of a term, over y, for 6 terms)

Result:
1:  2 x + y - y^3 / 6 + y^5 / 120 - y^7 / 5040 + y^9 / 362880
#+END_EXAMPLE

This isn't a bad approximation, see [[https://www.google.com/search?q=y+-+y%5E3+%2F+6+%2B+y%5E5+%2F+120+-+y%5E7+%2F+5040+%2B+y%5E9+%2F+362880][Google’s answer]] for comparison.

So, yes, calc can do college-level math, even if the answers aren't perfectly
simplified. It's not Mathematica, but it is free and integrated into emacs, so
it's definitely nice to have.

** Bit Manipulation

Quick! What bits are set on the number 925817? What, are you going to convert it
to binary and note positions of 1s? Ha! I laugh at such primitive techniques.

#+BEGIN_EXAMPLE
M-x calc
925817
b u  (unpack the bits into a vector)

Result
1:  [0, [3 .. 6], 13, [17 .. 19]]
#+END_EXAMPLE

How many bits is that?

#+BEGIN_EXAMPLE
v #  (count the number of items in a vector)

Result:
1:  9
#+END_EXAMPLE

This is convenient! So yes, calc has some nice functions for binary numbers. The
interesting thing about calc's binary number functions aren't just that you can
do bitwise operations such as AND and OR, but it has the notion of a word size
that it works with. Well, it'd have to do things like NOT.

Let's check it out.  First, we'll see what the number 925817 looks like in binary.

#+BEGIN_EXAMPLE
925817
d 2

Result:
1:  2#11100010000001111001
#+END_EXAMPLE

This is nice, but it'd be better to see the whole word.

#+BEGIN_EXAMPLE
d z  (Display leading zeroes)

Result:
1:  2#00000000000011100010000001111001
#+END_EXAMPLE

Ah, that's more like it. The word size by default is 32 bits, as you can see.
Or, wait, can you see? Hard to count. Let's verify it.

#+BEGIN_EXAMPLE
d 0  (go back to base-10 mode)
0  (we start with 0)
b n  (calculate the not)

Result:
1:  4294967295
#+END_EXAMPLE

Now we already know how to count the 1's...

#+BEGIN_EXAMPLE
b u v #

Reuslt:

1:  0000000032
#+END_EXAMPLE

Whoops, looks like we still have leading 0s.  But we've confirmed it, so let's just let it go for now.

Now, let's see what the number 925817 is if you reverse all the bits. I can't
take credit for this particular bit of cleverness, this technique comes straight
from calc's info pages.

#+BEGIN_EXAMPLE
d z  (get rid of leading 0s)
925817
b u  (unpack into a vector)
31 <tab> -  (tranform each bit position by subtracting it from 31, the tab just switches the items around on the stack)
b p  (repack the vector)

Result:
1:  2651090944
#+END_EXAMPLE

Woody Allen once praised New York by saying how he loves that you can go to
Chinatown and eat a crab in the middle of the night, but in reality what kind of
crazy person would need to do that? I feel the same way about all these
features. Will I really ever need to reverse the bits of a number? Not sure, but
I do love the way that calc has me covered for whatever I really want to do.

By the way, want to go to 64-bit mode?  Just change the word size.

#+BEGIN_EXAMPLE
b w 64  (change the word size to 64)
#+END_EXAMPLE

Now let's reverse the bits of 925817 again to see what we get. It'll be
amusingly huge!

#+BEGIN_EXAMPLE
925817
b u  (unpack into a vector)
63 <tab> -  (tranform each number by subtracting it from 31, the tab just switches the items around on the stack)
b p  (repack the vector)

Result:
1:  11386348903201767424
#+END_EXAMPLE

Ah, that's what it was. I was just about to give that same answer myself.

One more cool thing. If you give a negative word size, calc will interpret
binary number as 2's complement numbers. For example:

#+BEGIN_EXAMPLE
b w 32  (set the word size to 32)
2  (just to choose a simple number)
b n  (bitwise not)

Result:
1:  4294967293
#+END_EXAMPLE

And now with 2's complement!

#+BEGIN_EXAMPLE
b w -32  (set the word size to -32, in other words, a 2's complement version of 32 bit)
2
b n

Result:
1:  -3
#+END_EXAMPLE

Hope this helps you twiddle those bits in all the ways that make you happy.

* Random Notes

** Insert URL from Safari                                            :IRREAL:
:PROPERTIES:
:CREATED: [2018-08-04 Sat 17:44]
:END:
:LOGBOOK:
CLOCK: [2018-08-04 Sat 17:44]--[2018-08-04 Sat 17:45] =>  0:01
:END:

Responding to [[http://irreal.org/blog/?p=6924][yesterday's post]], Sacha asks if I could post the code for
=jcs-insert-url= for others to use. I thought I'd already done that but
apparently not. That's probably because except for the part identical to
=jcs-get-link=, which I /did/ [[http://irreal.org/blog/?p=2895][write about]], it's pretty trivial. In any event,
here it is:

#+BEGIN_SRC emacs-lisp
(defun jcs-insert-url ()
  "Insert URL of current browser page into Emacs buffer."
  (interactive)
  (insert (jcs-retrieve-url)))
#+END_SRC

The =jcs-retrieve-url= function does all the work, of course, and is
just the code that I abstracted out of =jcs-get-link= to actually
retrieve the URL from Safari:

#+BEGIN_SRC emacs-lisp
(defun jcs-retrieve-url ()
  "Retrieve the URL of the current Safari page as a string."
  (org-trim (shell-command-to-string
             "osascript -e 'tell application \"Safari\" to return URL of document 1'")))
#+END_SRC

One obvious problem with all this is that it works only for macOS. Not to
despair, though, because in the comments to the original post, [[http://irreal.org/blog/?p=6924#comment-3732979999][Brad Collins
suggests a solution]] that uses [[https://github.com/xuchunyang/grab-x-link][grab-x-link]] to do the same thing for FireFox and
Chrome on other systems. Be sure to read Brad's comment because there is---or at
least was---an issue with the MELPA version.

Finally, Sacha took the part about looking for ways to make your workflow easier
seriously and came up with a bit of Elisp to [[http://sachachua.com/blog/2018/01/org-mode-inserting-a-function-definition/][insert a function definition at the
point]], regardless of where it's defined.  That's very handy and I immediately
stole her code and used it to insert the two functions above. My old method was
to switch to =init.el=, find the function, copy it to the kill ring, switch back
to the original buffer, add the source block fences, and insert the code between
them.  Sacha's code did all of that for me and I didn't even have to leave my
current buffer. That's splendid. If you find yourself having to add function
definitions to your text, be sure to read Sacha's post. It will save you a lot
of time.

[[http://irreal.org/blog/?p=6926][Link]]

** Calc for Programmers                                              :IRREAL:
:PROPERTIES:
:CREATED: [2018-08-05 Sun 10:04]
:END:
:LOGBOOK:
CLOCK: [2018-08-05 Sun 10:04]--[2018-08-05 Sun 10:05] =>  0:01
:END:

After writing about Florian Adamsky's post on [[http://irreal.org/blog/?p=7040][acronyms in AUCTeX]], I snooped
around on his site and came across a [[https://florian.adamsky.it/2016/03/31/emacs-calc-for-programmers-and-cs.html][nice post]] on [[https://www.gnu.org/software/emacs/manual/html_node/calc/index.html][Emacs Calc]] from a programmer's
and computer scientist's point of view. As regular readers know, I've been
working to increase my calc-fu lately so I read the post with interest.

Adamsky demonstrates some of the Calc functions that are useful to programmers
and computer scientists. This includes such things as entering and displaying
numbers in various radixes and performing the standard logical operations on
(the usually binary representation of) numbers. He even shows how to add a new
“units” representation to Calc---in this case bits/bytes/bits per second.

Calc is a large subsystem and famously hard to master but worth the effort. It's
been described as a “poor man's Mathematica.” It's not nearly as powerful as
Mathematica, of course, but it's surprising how many things it can do. If you're
a programmer/computer scientist and an Emacs user you should spend a little time
investigating Calc. It really can make your life easier. An easy way to get
started is to read Adamsky's post. It covers only a small slice of Calc but will
give you an idea of its power.

[[http://irreal.org/blog/?p=7044][Link]]

** Parsing with Org-Element                                          :IRREAL:
:PROPERTIES:
:CREATED: [2018-08-10 Fri 17:55]
:END:

The other day, I saw [[https://www.reddit.com/r/emacs/comments/89bxe0/org_mode_longterm_time_tracking_for_freelancers/][this query]] on the reddit Emacs subreddit. I already have
solutions for this type of problem but I'm always interested in the how people
use Org mode to record and report data so I followed the link that primitiveinds
provided for [[https://alexpeits.github.io/programming/2017/02/12/org-timesheets.html][his solution]] to generating time reports.

Even if, like me, you already have your time tracking and reporting needs under
control, primitiveinds' solution is worth looking at for its own sake. It works
by looking for CLOCK entries in an Org buffer and accumulating the relevant
information in the CLOCK line as well data about the associated task. That might
seem like it would require routine but tedious text manipulation but
primitiveinds leverages the org-element functionality to easily handle the task.

He starts by calling =org-element-parse-buffer= to generate a tree
representation of the Org buffer. Then he uses =org-element-map= to examine each
CLOCK element (and only CLOCK elements) to extract the necessary
information. It's a great technique that can easily be adapted for other parsing
of Org data. The code that primitiveinds presents is easy to follow and he
provides a nice explanation of what it's doing.

If you need to programmatically examine Org data for further processing, you
should take a look at primitiveinds' post. It's definitely worth a read.

[[http://irreal.org/blog/?p=7073][Link]]

The relevant code:

#+begin_src emacs-lisp
(nconc
 '(("date" "project" "hours" "task"))
 '(hline)
 (let ((ast (org-element-parse-buffer 'element)))
   (org-element-map ast 'clock
     (lambda (x)
       (let* ((val (org-element-property :value x))
              (task (org-element-property :parent (org-element-property :parent x))))
         `(,(let ((year (org-element-property :year-start val))
                  (month (calendar-month-name
                          (org-element-property :month-start val)))
                  (day (org-element-property :day-start val)))
              ;; (insert (org-element-property :raw-value val))
              (format "%s %s, %s" month day year))
           ,(org-element-property :PROJECT task)
           ,(org-element-property :duration x)
           ,(org-element-property :title task)
           )))))
 '(hline)
 '(("" "total:" ":=vsum(@2..@-1);T" "")))
#+end_src

** Emacs Lisp Byte-Code                                              :IRREAL:
:PROPERTIES:
:CREATED: [2018-08-11 Sat 21:40]
:END:

Very few Emacs users---no matter how advanced---ever need to worry about the
specifics of the Elisp bytecode, or even, for that matter, that it
exists. Still, as guys like Chris Wellons [[http://nullprogram.com/blog/2014/01/04/][have shown]], it can sometimes be useful
to have a basic understanding of the bytecodes.

R Bernstein has put together a comprehensive, book-length [[http://rocky.github.io/elisp-bytecode.pdf][documentation on Elisp
bytecodes]]. After a short introduction, the documentation considers the bytecode
environment including the compiler, interpreter, and bytecode optimization. Then
there's a long section on the individual bytecode instructions.

Finally, there are sections on the changes in bytecodes between Emacs versions,
a table of opcodes, and a reference section. There's also a GitHub repository of
the [[https://github.com/rocky/elisp-bytecode][document source]].

As I said, you probably will never need this but if you do, you'll be /very/
glad to have Bernstein's documentation. It's another example of the vibrant
Emacs community.

[[http://irreal.org/blog/?p=7166][Link]]
** Formatting Tables                                                 :IRREAL:
:PROPERTIES:
:CREATED: [2018-10-28 Sun 09:13]
:END:

If you're like me, you automatically think of the Org mode table editor (or
Orgtbl minor mode) when you think of tables in Emacs. It's hard to beat that
functionality and Orgtbl mode makes it available everywhere in Emacs, even if
you're not in an Org buffer. Sometimes, though, you'd like to have special
formatting for some or all of the table. That's where =delim-col= comes in.

=Delim-col= is /built-in/ Emacs functionality that allows you to do things like
adjust what string separates the columns, add a beginning or ending string to
each item, add an ending string for each row, and adjust the padding in the
table. It can be really handy for copying and pasting and then reformatting
tables from an external source.

I didn't know about =delim-col= until I read about it [[https://emacsnotes.wordpress.com/2018/09/24/delim-col-a-handy-tool-for-creating-pretty-tables-and-converting-those-to-different-table-formats/][over at Emacs Notes]], where
you'll find a good explanation of the facility and what it can do. The Emacs
Notes post also offers at bit of Elisp to make choosing the strings and
delimiters a bit easier. By default you have to set them using a series of
=setq= statements if you want something different from the built-in choices. The
Emacs Notes codes arranges for you to be prompted for the values.

You probably won't need the =delim-col= functionality very often but when you do
it's much easier than using something like a keyboard macro.  Take a look at the
post and see if you don't agree.

[[http://irreal.org/blog/?p=7540][Link]]

** Org Mode Cookbook                                                 :IRREAL:
:PROPERTIES:
:CREATED: [2018-08-04 Sat 12:51]
:END:
:LOGBOOK:
CLOCK: [2018-08-04 Sat 12:51]--[2018-08-04 Sat 12:54] =>  0:03
:END:

Way back in 2014, I [[http://irreal.org/blog/?p=2575][posted]] about Eric Neilsen's excellent [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][Emacs org-mode
examples and cookbook]]. I recently came across a reference to it and was reminded
what a great resource it is. It's easy to browse through and just read one or
two entries when you have time. In skimming through it, I learned---or perhaps
relearned---how to [[http://ehneilsen.net/notebook/orgExamples/org-examples.html#sec-10][insert in-line calculations in a document]].

As I wrote in the original post, Neilsen is a researcher and his cookbook is
oriented at using Org mode to produce documents of various types. Still, that
covers a lot of territory and there are many good examples of powerful Org mode
use cases in it. The Document has moved or, really, taken up a second
residence. It was originally hosted at [[http://fnal.gov/][Fermilab]], where Neilsen works, and it's
still there but it's also available at his own site. The two documents are
identical so it doesn't matter if you use the new link or the original one
pointing to FNAL.

If you're an Org user, especially if you use Org to produce documents,
you should take a look at Neilsen's cookbook and bookmark it for future
use.

[[http://irreal.org/blog/?p=6894][Link]]

** How to paste then copy
:PROPERTIES:
:CREATED: [2018-08-11 Sat 21:47]
:END:
:LOGBOOK:
CLOCK: [2018-08-11 Sat 21:47]--[2018-08-11 Sat 21:48] =>  0:01
:END:

Question: how to set a mark such that all subsequent copy operations move their
text to that exact mark.

Answer: use ~cua-selection-mode~!  See
https://www.reddit.com/r/emacs/comments/8ekz0u/how_to_pastethencopy/.

/Update/: turns out it doesn’t work so well, disabled it again.
** Tramp and Telnet over non-standard ports
:PROPERTIES:
:CREATED: [2018-12-29 Sat 15:58]
:END:

Syntax: ~/telnet:HOST#PORT:~, works also with other protocols.

** Magit Walkthrough
:PROPERTIES:
:CREATED: [2018-08-11 Sat 21:05]
:END:

https://emacsair.me/2017/09/01/magit-walk-through/
** Fractals in Emacs
:PROPERTIES:
:CREATED: [2018-08-04 Sat 13:01]
:END:
:LOGBOOK:
CLOCK: [2018-08-04 Sat 13:01]--[2018-08-04 Sat 13:03] =>  0:02
:END:

From https://nullprogram.com/blog/2012/09/14/

#+begin_src emacs-lisp
(defun sierpinski (s)
  (pop-to-buffer (get-buffer-create "*sierpinski*"))
  (fundamental-mode) (erase-buffer)
  (labels ((fill-p (x y)
                   (cond ((or (zerop x) (zerop y)) "0")
                         ((and (= 1 (mod x 3)) (= 1 (mod y 3))) "1")
                         (t (fill-p (/ x 3) (/ y 3))))))
    (insert (format "P1\n%d %d\n" s s))
    (dotimes (y s) (dotimes (x s) (insert (fill-p x y) " "))))
  (image-mode))

(defun mandelbrot ()
  (pop-to-buffer (get-buffer-create "*mandelbrot*"))
  (let ((w 400) (h 300) (d 32))
    (fundamental-mode) (erase-buffer)
    (set-buffer-multibyte nil)
    (insert (format "P6\n%d %d\n255\n" w h))
    (dotimes (y h)
      (dotimes (x w)
        (let* ((cx (* 1.5 (/ (- x (/ w 1.45)) w 0.45)))
               (cy (* 1.5 (/ (- y (/ h 2.0)) h 0.5)))
               (zr 0) (zi 0)
               (v (dotimes (i d d)
                    (if (> (+ (* zr zr) (* zi zi)) 4) (return i)
                      (psetq zr (+ (* zr zr) (- (* zi zi)) cx)
                             zi (+ (* (* zr zi) 2) cy))))))
          (insert-char (floor (* 256 (/ v 1.0 d))) 3))))
    (image-mode)))
#+end_src
** Introduction to Babel

Tutorial from http://orgmode.org/worg/org-contrib/babel/intro.html

*** Source Code Execution

#+begin_src hy
  (print "Hello, There!")
#+end_src

#+RESULTS:
: Hello, There!

#+begin_src sh
  echo "This file takes up `du -h emacs-org-babel-tutorial.org | sed 's/\([0-9k]*\)[ ]*emacs-org-babel-tutorial.org/\1/'`"
#+end_src

#+RESULTS:
: This file takes up 4.0K

#+begin_src R :colnames yes
  words <- tolower(scan("emacs-org-babel-tutorial.org", what="", na.strings=c("|",":")))
  t(sort(table(words[nchar(words) > 3]), decreasing=TRUE)[1:10])
#+end_src

#+RESULTS:
| #+begin_src | #+end_src | #+results: | date | plus | today's | :results | hello, | import | is") |
|-------------+-----------+------------+------+------+---------+----------+--------+--------+------|
|           5 |         5 |          4 |    3 |    3 |       3 |        2 |      2 |      2 |    2 |

**** Capturing the Results of Code Evaluation

#+begin_src python :results value
  import time
  print("Hello, today's date is %s" % time.ctime())
  print("Two plus two is")
  return 2 + 2
#+end_src

#+RESULTS:
: 4

#+begin_src python :results output
  import time
  print("Hello, today's date is %s" % time.ctime())
  print("Two plus two is")
  2 + 2
#+end_src

#+RESULTS:
: Hello, today's date is Sun Jun 26 16:04:36 2016
: Two plus two is

**** Session-based Evaluation

Have a look into /Emacs Speaks Statistics/

**** Arguments to Code Blocks

#+name: square
#+header: :var x = 0
#+begin_src python
  return x*x
#+end_src

#+call: square(x=6)

#+RESULTS:
: 36

#+tblname: fibonacci-inputs
| 1 | 2 | 3 | 4 |  5 |  6 |  7 |  8 |  9 | 10 |
| 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 |

#+name: fibonacci-seq
#+begin_src emacs-lisp :var fib-inputs=fibonacci-inputs
  (defun fibonacci (n)
    (if (or (= n 0) (= n 1))
        n
      (+ (fibonacci (- n 1))
         (fibonacci (- n 2)))))

  (mapcar (lambda (row)
            (mapcar #'fibonacci row))
          fib-inputs)
#+end_src

#+RESULTS: fibonacci-seq
| 1 | 1 | 2 |  3 |  5 |   8 |  13 |  21 |   34 |   55 |
| 1 | 3 | 8 | 21 | 55 | 144 | 377 | 987 | 2584 | 6765 |

**** In-line Code Blocks

In-line code can be call without header arguments (like so: src_sh{date}) or
with header arguments (like so: src_python[:results value]{return 10 + 10}).

**** Code Block Body Expansion

Preview: =C-c C-v v=, bound to =org-babel-expand-src-block=

#+tblname: data
| username | john-doe |
| password | abc123   |

#+begin_src emacs-lisp :var data=data
(setq my-special-username (first (first data)))
(setq my-special-password (first (second data)))
#+end_src

**** A Meta-programming Language for Org-mode

#+name: directories
#+begin_src sh :results replace
  cd ~ && du -sc * | grep -v total
#+end_src

#+RESULTS: directories
|   538604 | Desktop   |
| 77332656 | Documents |
|  1206668 | Mail      |
|        8 | News      |

#+name: directory-pie-chart
#+begin_src R :session R-pie-example :var dirs=directories
  pie(dirs[,1], labels = dirs[,2])
#+end_src

#+RESULTS: directory-pie-chart

Note: the syntax =#+name: directory-pie-chart(dirs=directories)= did not work.

**** Using Code Blocks in Org Tables

***** Example 1: Data Summaries Using R

#+name: tbl-example-data
#+begin_src R
  runif(n=5, min=0, max=1)
#+end_src

#+name: R-mean
#+begin_src R :var x=""
  colMeans(x)
#+end_src

#+tblname: summaries
|              mean |
|-------------------|
| 0.574235895462334 |
#+TBLFM: @2$1='(org-sbe "R-mean" (x "tbl-example-data()"))

***** Example 2: Babel Test Suite

/No notes/

*** The Library of Babel

#+lob: square(x=6)

Does not do what I expected …

*** Literate Programming

#+name: hello-world-prefix
#+begin_src sh :exports none
  echo "/-----------------------------------------------------------\\"
#+end_src

#+name: hello-world-postfix
#+begin_src sh :exports none
  echo "\-----------------------------------------------------------/"
#+end_src

#+name: hello-world
#+begin_src sh :tangle hello.sh :exports none :noweb yes
  <<hello-world-prefix>>
  echo "|                       hello world                         |"
  <<hello-world-postfix>>
#+end_src

Tangling with =C-c C-v t=.

** Presentations with ~org-reveal~

Website: https://github.com/yjwen/org-reveal

Sample:

#+BEGIN_SRC org
  #+title: Foo!
  #+author: bar
  
  #+options: author:t toc:t num:nil date:nil timestamp:nil
  #+reveal_theme: sky
  
  * Slide 1
  * Slide 2
  ** Subslide 1
  ** Subslide 2
  - Item 1
  - Item 2
  
   | a | b | d |
   |---+---+---|
   | 1 | 2 | 3 |
  * Slide 3
#+END_SRC
** Writing a PhD thesis with Org Mode

From: https://write.as/dani/writing-a-phd-thesis-with-org-mode

*TLDR*: I started using Emacs about 3 years ago. I couldn't be more grateful to
have seen the light, and to have been rescued from the darkness of Windoze,
Goggle and/or friends. After enlightenment, I've taken upon myself the task of
customising an environment to write my PhD thesis with Org Mode.*

*** Why

Post created in response to the [[https://www.reddit.com/r/emacs/comments/9ynsvc/write_a_thesis_using_emacs_and_orgmode/][current thread]] in /r/emacs/ on thesis writing
with Org Mode.\\ I see most people's reason to avoid Org mode for scientific
writing is the fact that supervisors or co-authors use Mic. Word. I'll try to
argue that that's not enough reason to accept subpar tools.

*** What I'll talk about

I'll mention a bit of my motivations, and then I'll discuss how to make use of
(mostly) built in Org functionality such as tagging, export, [[https://orgmode.org/manual/In_002dbuffer-settings.html][setupfiles]] and
includes, reference management, keyboard shortcuts and advanced searching; all
with the purpose of building a useful thesis writing environment. Readers should
have a minimum knowledge of Org mode, the Org export system and LaTeX.

*** My requirements

Here in the Netherlands, most PhD thesis consist of an introduction, 3 to 4
research chapters (as submitted for publication), a summary, bibliography and
appendices. What this means for me is that my writing environment has to
/necessarily/ satisfy the following *minimum requirements*:

- Inclusion of (parts of) external files
- Keeping track of references
- Include and reference figures
- Version control documents
- Support for sharing with my supervisor in whatever format he wants

Failure to comply with any of these means the editor is unfit for
purpose^{#fn.1”>1}. Unfortunately, this set of requirements are not seamlessly
satisfied by likes of Mic. Word or G. Docs. I reckon they can probably be
configured to satisfy them, but why bother.

Additionally, a PhD thesis writing environment should also provide the following
features:

- Extended searching facilities for both text and references
- Simple syntax for tables and equations
- Support within a proper text editor
- Shortcuts to reach my files and build the thesis

To the best of my knowledge, /only/ Emacs with Org Mode + ox-latex provide all
of these out of the box.

*** Moulding Org Mode for thesis writing

Most of my inspiration comes from reading Kitchin's blogs and code, and reading
the Org Mode documentation, mailing list and Emacs Stack Exchange. Here' I'll go
one by one through all of the requirements listed above, and how to deal with
them.

**** Prelude: File structure

I have a main /thesis.org/ document, with latex heading declarations and a
commented setup file. I also have /research.org/ files, in different
directories, with their own latex heading declarations and commented setup
files.

The first lines of /thesis.org/ look like the following:

#+BEGIN_src org
  #  -*- mode: org; org-latex-title-command: ""; org-latex-toc-command: "" -*-
  #+TITLE: Thesis Title
  #+LATEX_CLASS: mimosis
  # Setupfile with #+LATEX_HEADER, #+OPTIONS and explanations
  #+SETUPFILE: thesis.setup
  #+LATEX_HEADER: \KOMAoptions{fontsize=12pt,headings=small}
  #+LATEX_HEADER: \bibliography{~/Papers/bibtex/Publications}
  #+EXCLUDE_TAGS: journal noexport
  
  * Frontmatter :ignore:
  #+LATEX: \frontmatter
  #+INCLUDE: ./Title.org
  #+LATEX: \tableofcontents
  
  * Mainmatter :ignore:
  #+LATEX: \mainmatter
  
  * Introduction
  * Research 1
  #+INCLUDE: "../research1/research.org::*Abstract" :only-contents t
  Some stuff.
  #+INCLUDE: "../research1/research.org" :lines "5-"
  
  * Research 2
  ...
#+END_src

And the first lines and structure overview of the multiple /research.org/ files:

#+BEGIN_src org
  #+TITLE: Research
  #+LATEX_CLASS: elsarticle
  #+LATEX_CLASS_OPTIONS: [authoryear,preprint,11pt]
  #+SETUPFILE: paper.setup
  #+LATEX_HEADER:\bibliography{./ref/Publications-research}
  #+EXCLUDE_TAGS: thesis noexport
  
  * Frontmatter :ignore:journal:
  #+LATEX: \begin{frontmatter}
  ** Author List :ignore: Abstract :ignore: Keywords :ignore:
  #+LATEX: \end{frontmatter}
  * Introduction
  ...
#+END_src

**** Inserting (parts of) external files

I write my research chapters with LaTeX classes targeting the journal's
format. That means that a research chapter may be written with the =elsarticle=
class, whereas the thesis as a whole is written with the =mimosis= [[https://github.com/Submanifold/latex-mimosis][class]], a
derivative of KOMA =scrbook=. Here's the class configuration for both:

#+begin_src emacs-lisp
(add-to-list 'org-latex-classes
             '("elsarticle"
               "\\documentclass{elsarticle}
                [NO-DEFAULT-PACKAGES]
                [PACKAGES]
                [EXTRA]"
               ("\\section{%s}"
                . "\\section*{%s}") ("\\subsection{%s}"
                . "\\subsection*{%s}") ("\\subsubsection{%s}"
                . "\\subsubsection*{%s}") ("\\paragraph{%s}"
                . "\\paragraph*{%s}") ("\\subparagraph{%s}"
                . "\\subparagraph*{%s}")))
(add-to-list 'org-latex-classes
             '("mimosis"
               "\\documentclass{mimosis}
                [NO-DEFAULT-PACKAGES]
                [PACKAGES]
                [EXTRA]
                \\newcommand{\\mboxparagraph}[1]{\\paragraph{#1}\\mbox{}\\\\}
                \\newcommand{\\mboxsubparagraph}[1]{\\subparagraph{#1}\\mbox{}\\\\}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}"
                . "\\section*{%s}") ("\\subsection{%s}"
                . "\\subsection*{%s}") ("\\subsubsection{%s}"
                . "\\subsubsection*{%s}") ("\\mboxparagraph{%s}"
                . "\\mboxparagraph*{%s}") ("\\mboxsubparagraph{%s}"
                . "\\mboxsubparagraph*{%s}")))
#+END_src

Research chapters print the bibliography on their own, and they may contain
acknowledgements that shouldn't be present in the middle of the thesis, so they
should be excluded. In other to insert research chapters into my thesis, I use
Org's =#+INCLUDE= derivative:

#+begin_src org
  #+INCLUDE: file.org
#+end_src

In order to not include the some parts of the file, i.e., to exclude the title,
setupfile and headers, I narrow down the lines:

#+begin_src org
  # Include line 5 until the end of the file
  #+INCLUDE: file.org :lines 5-
#+end_src

In order to exclude parts of the file, I tag research chapter headings that are
only meant for publication with a =:journal:= tag (such as the bibliography or
acknowledgements). This way they are automatically excluded from the thesis (see
the =#+EXCLUDE_TAGS:= derivative in the /thesis.org/ file). Also, I could have
thesis specific content in the /research.org/ document tagged with =:thesis:=,
and it would be excluded in the /research.org/ export, but I currently don't
have any.

Now, the most important piece of advice I can give anyone is to *learn how to
use tags*, =EXCLUDE_TAGS= and the org-plus-contributions =ignore= tag. With the
=ignore= tag we separate the structuring of the text as a physical document from
the structuring of the text as a semantic unity.  This allows an extremely fine
control over pieces of text to include into another document. For example, in a
research chapter written with the =elsarticle= class, the abstract has to be
included in the Frontmatter. By tagging a headline as follows:

#+begin_src org
  ** Abstract :ignore:
#+end_src

I can write the research abstract in it's own heading, pretend that the heading
itself does not exist (so it does not trigger =/begin{document}=), only its
contents, and then include the contents in the thesis in an arbitrary location:

#+begin_src org
  # in thesis.org
  #+INCLUDE: "research.org::*Abstract" :only-contents t
#+end_src

The =:ignore:= tag is one of the best Org mode features, in my opinion.  It's
key to my workflow, and a shame to see it's not a part of Org core, but rather a
contribution to be found in /ox-extra.el/. To activate it, add the following to
your /init/:

#+BEGIN_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+END_src

The realisation that it's possible to have such fine control over where to
include or exclude pieces of text opens the door to all sort of interesting
experiments: putting figures and captions directly into beamer or org-reveal
presentations, creating conference posters, writing blog posts, etc.

**** Keep track of references

For backwards compatibility I still use Mendeley to track literature. I export
bibtex files for each research project individually, and also a master bibtex
for use in the thesis. These documents are saved to =~/Papers/bibtex/=, but for
the research chapters, I keep local copies under
=./ref/Publications-research.bib=.\\ To insert citations, I use [[https://github.com/jkitchin/org-ref][org-ref.]] It's
documentation says it all. After setting up local bibliography files with the
derivative =#+BIBLIOGRAPHY=, press =C-c ]= to see a list of publications and
insert them in place. I also prefer to have =parencite= citations instead of
=cite=, because they work nicely with BibLaTeX. My setup for org-ref:

#+begin_src emacs-lisp
(with-eval-after-load 'org-ref ;; see org-ref for use of these variables
  (setq org-ref-default-bibliography '("~/Papers/bibtex/Publications.bib")
        org-ref-pdf-directory "~/Papers/MendeleyDesktop/"
        org-ref-get-pdf-filename-function 'org-ref-get-mendeley-filename
        bibtex-completion-pdf-field "file" org-latex-prefer-user-labels t
        org-ref-default-citation-link "parencite"
        ;; bibtex-dialect 'biblatex
        )

  (defun org-ref-open-pdf-at-point-in-emacs ()
    "Open the pdf for bibtex key under point if it exists."
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (pdf-file (funcall org-ref-get-pdf-filename-function key)))
      (if (file-exists-p pdf-file)
          (find-file-other-window pdf-file)
        (message "no pdf found for %s" key))))

  ;; https://github.com/jkitchin/org-ref/issues/597
  (defun org-ref-grep-pdf (&optional _candidate)
    "Search pdf files of marked CANDIDATEs."
    (interactive)
    (let ((keys (helm-marked-candidates))
          (get-pdf-function org-ref-get-pdf-filename-function))
      (helm-do-pdfgrep-1
       (-remove (lambda (pdf) (string= pdf ""))
                (mapcar (lambda (key) (funcall get-pdf-function key))
                        keys)))))

  (helm-add-action-to-source "Grep PDF" 'org-ref-grep-pdf helm-source-bibtex 1)

  (setq helm-bibtex-map (let ((map (make-sparse-keymap)))
                          (set-keymap-parent map helm-map)
                          (define-key map (kbd "C-s") (lambda () (interactive) (helm-run-after-exit 'org-ref-grep-pdf)))
                          map))
  (push `(keymap . ,helm-bibtex-map) helm-source-bibtex)

  (setq org-ref-helm-user-candidates
        '(("Open in Emacs" . org-ref-open-pdf-at-point-in-emacs))))
#+end_src

**** Include and reference figures

For each research project I keep a =./media= directory, where all my figures
live. You can include figures in Org mode by using the following syntax:

#+begin_src org
  #+NAME: figurename
  #+CAPTION: This is a figure caption
  [[path_to_figure][link_description]] 
#+end_src

Currently there is a bug in the ELPA version of Org mode, such that relative
paths to figures in =#+INCLUDE= 'd files aren't adapted with respect to the
including file, so the latex export cannot find them.  I've [[https://code.orgmode.org/bzg/org-mode/commit/d81a1d088c74e605c99e90a2835c55df5144f43e][submitted a fix]]
which should land in the next release of Org.

**** Version control documents

[[https://magit.vc/][Magit]]. I thought about having the research chapters as git submodules in a
thesis git project directory, but I currently don't. This would allow me to
always have the thesis code in a saved state, even if I further work on my
research chapters to answer to reviewers questions.

**** Support for sharing with my supervisor

Unfortunately, my supervisor likes to write comments in Mic. Word. I give in
that sharing your writing with colleagues is a fundamental part of
research.\\ Fortunately, [[https://github.com/jkitchin/scimax/blob/master/ox-word.el][ox-word]] export via Pandoc & LaTeX is capable of
creating nice looking, structured Word files which I send to my supervisor. I
then manually work through each comment step by step, though I'm looking for a
way to improve this part of my workflow. I think the Emacs community is missing
a minor mode to track Word document changes from within Org Mode. There are some
ideas laying around on how to implement it [[https://lists.gnu.org/archive/html/emacs-orgmode/2015-06/msg00246.html][hidden deep in the mailing list]], or
in [[https://emacs.stackexchange.com/questions/34923/merging-changes-to-from-docx-files-into-org-files][this Emacs Exchange thread]].

I may update this post with more information later.

**** Extended search facilities

By extended search facilities I mean the ability to quickly search for
information in references, and to keep notes linked to the literature.  For
searching I make use of [[https://github.com/jkitchin/org-ref/issues/597][org-ref + pdfgrep]], as shown in my org-ref setup. For
notes linked to documents I've recently started to use [[https://github.com/weirdNox/org-noter][Org-noter.]]

**** Simple syntax for tables and equations

Org tables are a pleasure to work with. The following:

#+BEGIN_EXAMPLE
| a | b | c |
|---+---+---|
| 1 | 2 | 3 |
#+END_EXAMPLE

Turns into:

| a   | b   | c   |
|-----+-----+-----|
| 1   | 2   | 3   |

Equations can be written in LaTeX:

#+BEGIN_EXAMPLE
\frac{d \vec{M} (t)}{dt} = \vec{M} (t) \times \gamma \vec{B} (t)
#+END_EXAMPLE

will become /omitted/

**** Support within a proper text editor

No need to talk about the synergy of using Emacs to edit text. I personally
started using Spacemacs without Evil mode, because I find it aesthetically
pleasing and because it offers great support for the languages I use the most,
and excellent integration with Helm and Org.\\ The following configurations make
the Org editing experience a bit nicer, in my opinion:

#+BEGIN_src emacs-lisp
;; Writegood https://github.com/bnbeckwith/writegood-mode
(add-hook 'org-mode-hook 'writegood-mode)

;; https://github.com/cadadr/elisp/blob/master/org-variable-pitch.el
(use-package org-variable-pitch
  :load-path "~/Elisp")
(add-hook 'org-mode-hook 'org-variable-pitch-minor-mode)

(setq visual-fill-column-width 120 visual-fill-column-center-text t)
(add-hook 'org-mode-hook 'visual-line-mode)

;; https://github.com/joostkremers/visual-fill-column
(add-hook 'org-mode-hook 'visual-fill-column-mode)
(add-hook 'org-mode-hook 'org-display-inline-images)

;; I have a modified version of the following:
;; https://github.com/lepisma/rogue/blob/master/config.el
(load-file "~/Projects/rogue/config.el")
(add-hook 'org-mode-hook '(lambda () (setq-local line-spacing 5)))

;; Aesthetical enhancements.
(setq org-fontify-quote-and-verse-blocks t
      org-hide-macro-markers t
      org-fontify-whole-heading-line t
      org-fontify-done-headline t
      org-hide-emphasis-markers t) 
#+END_src

**** Shortcuts to reach my files and build the thesis

I have a hydra (defined in Spacemacs as a transient-state) to move between my
Thesis files:

#+begin_src emacs-lisp
;; Spacemacs hydra.
(spacemacs|define-transient-state
 thesis-menu
 :title "Ph.D. Thesis Menu"
 :doc "
^Main Files^ ^Chapters^ ^Actions^
^^^^^^^^-------------------------------------------
_m_: Thesis        _1_: Research 1  _o_: Open Thesis.pdf externally
_t_: Title page    _2_: Research 2  _c_: Async compile file
_i_: Introduction  _3_: Research 3  _a_: things
_s_: thesis.setup  _4_: Research 4  ^ ^
"
 :bindings
 ("a" things :exit t)
 ("m" (find-file "~/thesis/thesis.org") :exit t)
 ("t" (find-file
       "~/thesis/titlepage.org") :exit t)
 ("s" (find-file
       "~/thesis/thesis.setup") :exit t)
 ("i" (find-file
       "~/thesis/intro/intro.org") :exit t)
 ("1" (find-file
       "~/thesis/ch1/research.org") :exit t)
 ("2" (find-file
       "~/thesis/ch2/research.org") :exit t)
 ("3" (find-file
       "~/thesis/ch3/research.org") :exit t)
 ("4" (find-file
       "~/thesis/ch4/research.org") :exit t)
 ("o" (shell-command "open
        ~/thesis/thesis.pdf" :exit t))
 ("c" (org-latex-export-to-pdf :async t)
  :exit t))

(global-set-key (kbd "H-t") 'spacemacs/thesis-menu-transient-state/body)
#+end_src
** Gnus and notmuch

Currently working: notmuch for nnmaildir backend.  However, I also have a local
nnimap-backend, which uses Maildir format locally.  It would be nice to have
this working with notmuch as well.

Relevant functions:
- ~nnir-compose-result~ :: Goes over the results of notmuch (stored in the
     buffer ~*nnir*~ (with an additional leading space) and decides which lines
     to keep;
- ~nnir-notmuch-remove-prefix~ :: a server-local variable to decide what to
     remove from the lines in ~*nnir*~.

** Summary of Search and Replace Commands in Emacs
[2016-08-13 Sat 17:50]

http://www.omps.in/blog/2016/01/20/day-10-search-and-replace-using-regex/
** Bookmarks with Org-mode
:PROPERTIES:
:CREATED: [2018-07-08 Sun 09:29]
:END:

[[http://karl-voit.at/2014/08/10/bookmarks-with-orgmode/]]

** Inserting a function definition                                     :CHUA:
:PROPERTIES:
:CREATED: [2018-08-04 Sat 17:40]
:END:
:LOGBOOK:
CLOCK: [2018-08-04 Sat 17:40]--[2018-08-04 Sat 17:42] =>  0:02
:END:

From [[http://sachachua.com/blog/2018/01/org-mode-inserting-a-function-definition/][Sacha Chua]].

While nudging jcs to add a definition of =jcs-insert-url= to the blog post about
[[http://irreal.org/blog/?p=6924][Making Things Easier]], I realized it might be handy to have a quick function for
inserting a function definition without thinking about where it's defined. This
tries to use the definition from the source, and it can fall back to using the
stored function definition if necessary. There's probably a better way to do
this, but this was small and fun to write. =)

Naturally, I used it to insert itself:

#+begin_src emacs-lisp
(defun my/org-insert-defun (function)
  "Inserts an Org source block with the definition for FUNCTION."
  (interactive (find-function-read))
  (let* ((buffer-point (condition-case nil
                           (find-definition-noselect function nil)
                         (error nil)))
         (new-buf (car buffer-point))
         (new-point (cdr buffer-point))
         definition)
    (if buffer-point
      (with-current-buffer new-buf ;; Try to get original definition
        (save-excursion
          (goto-char new-point)
          (setq definition (buffer-substring-no-properties
                            (point)
                            (save-excursion (end-of-defun) (point))))))
      ;; Fallback: Print function definition
      (setq definition (concat (prin1-to-string
                                (symbol-function function))
                               "\n")))
    (insert "#+begin_src emacs-lisp\n" definition "#+end_src\n")))
#+end_src

** Tramping into GCloud instances from within emacs                  :IRREAL:

From https://gist.github.com/jackrusher/36c80a2fd6a8fe8ddf46bc7e408ae1f9 via [[https://irreal.org/blog/?p=8126][Irreal]].

#+begin_src emacs-lisp
;; make sure you've set your default project with:
;; gcloud config set project <project-name>

(require 'tramp)
(add-to-list 'tramp-methods
  '("gcssh"
    (tramp-login-program        "gcloud compute ssh")
    (tramp-login-args           (("%h")))
    (tramp-async-args           (("-q")))
    (tramp-remote-shell         "/bin/sh")
    (tramp-remote-shell-args    ("-c"))
    (tramp-gw-args              (("-o" "GlobalKnownHostsFile=/dev/null")
                                 ("-o" "UserKnownHostsFile=/dev/null")
                                 ("-o" "StrictHostKeyChecking=no")))
    (tramp-default-port         22)))

;; ... after which it's as easy as:
;;
;; C-x C-f /gcssh:compute-instance:/path/to/filename.clj
#+end_src
